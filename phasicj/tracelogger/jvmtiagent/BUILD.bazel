package(
    default_visibility = ["//phasicj/tracelogger:__subpackages__"],
)

cc_library(
    name = "statically_linked",
    srcs = ["statically_linked.cc"],
    hdrs = ["statically_linked.h"],

    # This library defines callbacks meant to be statically linked into a JVM.
    linkstatic = True,
    deps = [":lifetime_event_callbacks"],
)

cc_library(
    name = "lifetime_event_callbacks",
    srcs = ["lifetime_event_callbacks.cc"],
    hdrs = ["lifetime_event_callbacks.h"],
    deps = [
        "@boost//:log",
        "@com_google_protobuf//:protobuf",
    ],
)

cc_library(
    name = "dynamically_linked",
    srcs = ["dynamically_linked.cc"],
    hdrs = ["dynamically_linked.h"],
    deps = [":lifetime_event_callbacks"],

    # This library defines callbacks meant to be dynamically linked into a JVM.
    alwayslink = True,
)

# TODO(dwtj) : I want to be able to build the agent as a standalone dynamic
# library deliverable, but its name needs to vary depending upon the target
# platform.It seems that I can't use a select expression in the name of a
# `cc_binary`, so I'm instead making multiple binaries. But this is misleading:
# for example, a `dylib` file is built during a linux build, but it is really
# a `so` file.
#
# So, what's the right way to do this.
alias(
    name = "pjtracelogger",
    actual = select({
        "@bazel_tools//src/conditions:darwin": "libpjtracelogger.dylib",
        "@bazel_tools//src/conditions:linux_x86_64": "libpjtracelogger.so",
    }),
)

cc_binary(
    name = "libpjtracelogger.dylib",
    linkshared = True,
    linkstatic = True,
    deps = ["dynamically_linked"],
)

cc_binary(
    name = "libpjtracelogger.so",
    linkshared = True,
    linkstatic = True,
    deps = ["dynamically_linked"],
)
